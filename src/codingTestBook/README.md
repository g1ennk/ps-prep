# 코딩 테스트 합격자 되기: 자바 편

<!-- TOC -->
* [코딩 테스트 합격자 되기: 자바 편](#코딩-테스트-합격자-되기-자바-편)
  * [0. INTRO](#0-intro)
    * [코딩 테스트를 준비하기 전에](#코딩-테스트를-준비하기-전에)
    * [코딩 테스트 효율적으로 준비하기](#코딩-테스트-효율적으로-준비하기)
    * [알고리즘의 효율 분석](#알고리즘의-효율-분석)
    * [코딩 테스트 필수 문법](#코딩-테스트-필수-문법)
  * [1. 배열](#1-배열)
    * [배열 개념](#배열-개념)
    * [ArrayList](#arraylist)
    * [몸풀기 문제](#몸풀기-문제)
    * [모의 테스트](#모의-테스트)
  * [2. 스택](#2-스택)
  * [3. 큐](#3-큐)
  * [4. 해시](#4-해시)
  * [5. 트리](#5-트리)
  * [6. 집합](#6-집합)
  * [7. 그래프](#7-그래프)
  * [8. 백트래킹](#8-백트래킹)
  * [9. 정렬](#9-정렬)
  * [10. 시뮬레이션](#10-시뮬레이션)
  * [11. 동적 계획법](#11-동적-계획법)
  * [12. 그리디](#12-그리디)
<!-- TOC -->

## 0. INTRO

- 책 구성: 이론 -> 몸풀기 문제 -> 실전 모의 테스트 문제
- 코드: https://github.com/retrogemHK/codingtest_java
- 97문제 구성: 본문 82 문제 + 모의고사 15 문제

### 코딩 테스트를 준비하기 전에

1. 신입 개발자가 꼭 되고 싶은 여러분
    - 타인의 풀이로 사고 넓히기
    - 나만의 테스트 케이스 추가해보기?
2. 아는 것과 모르는 것을 명확하게
    - 기록하기: 문제를 못풀어도 어디까지 생각해봤는지 우선 기록하여 사고 흐름을 기록하자
    - 시험 보듯 공부하기: 시간적으로 제한을 두어 시험 보듯 공부하기
    - 짧은 시간으로는 코딩테스트 준비가 어렵다: 최소 한 달에서 두 달정도 매우 집중해서 공부하자.
    - 나만의 언어로 요약하기

### 코딩 테스트 효율적으로 준비하기

1. 언어 선택하기: 자바로!
2. 문제 분석 연습하기
    - 문제를 쪼개서 분석하기
    - 제약 사항을 파악하고 테스트 케이스를 추가하기
    - 입력값을 분석하기 (시간 복잡도)
    - 그리디 접근 시 근거 명확히 하기
    - 데이터 흐름이나 구성 파악하기
3. 의사 코드로 설계하는 연습하기
    - 의사코드란, 프로그래밍 언어가 아니고 일정한 형식이 없는 자연어
    - 작성 방법
        - 세부 구현이 아닌 동작 중심으로 작성하기
        - 문제 해결 순서로 작성하기
        - 충분히 테스트 하기

### 알고리즘의 효율 분석

1. 시간 복잡도란?
    - 알고리즘의 성능을 나타내는 지표로, 입력 크기에 대한 연산 횟수의 상한을 의미한다.
    - 빅오 표기법으로 최고차항만 남기고 계수 지우기
    - 코딩 테스트 문제에는 제한 시간이 있으므로, 문제를 분석한 후에 빅오 표기법으로 해당 알고리즘 적용 시 제한 시간 내에 출력값이 나올 수 있는지 확인한다.
2. 시간 복잡도 계산해보기
    - 문제 정의 -> 연산 횟수 측정 -> 시간 복잡도 분석

### 코딩 테스트 필수 문법

1. 원시 타입과 참조 타입
    - 원시 타입 ex) int, char, long
    - 참조 타입 ex) Integer, String, Character
2. 컬렉션 프레임워크: 리스트, 스택, 큐, 데크, 해시맵, 문자열(불변), 문자열(가변, StringBuilder)
3. 코딩 테스트 코드 구현 노하우
    - 조기 반환
    - 보호 구문: 본 로직 전 예외 처리 코드 추가
    - 제네릭
    - 스트림

## 1. 배열

### 배열 개념

- 인덱스와 값을 일대일 대응해 관리하는 자료구조
- 정확한 데이터 개수를 안다면 더 간결하고 속도가 빠른 배열 사용하고, 개수를 알 수 없다면 ArrayList 사용하기
    - 배열은 초기 크기 선언이 필요한반면 배열 리스트는 동적이기 때문

### ArrayList

- 초기화, add, get, remove 등등
- 배열 연산의 시간 복잡도: 인덱스를 안다면 시간 복잡도는 O(1)
  - 맨 뒤 삽입: 한 번에 추가하기 때문에 O(1)
  - 맨 앞 삽입: 모든 데이터를 한 칸씩 밀어야하기 때문에 O(N)
  - 중간 삽입: 중간 이후부터 한 칸씩 밀어야 하기 때문에 O(N)
- 배열 선택 시 고려할 점
  - 할당할 수 있는 메모리 크기 확인
  - 중간에 데이터 삽입이 많은지 확인

### 몸풀기 문제

1. 배열 정렬하기
   
2. 배열 제어하기

### 모의 테스트

1. 두 개 뽑아서 더하기
2. 모의고사
3. 행렬의 곱셈
4. 실패율
5. 방문 길이

## 2. 스택

## 3. 큐

## 4. 해시

## 5. 트리

## 6. 집합

## 7. 그래프

## 8. 백트래킹

## 9. 정렬

## 10. 시뮬레이션

## 11. 동적 계획법

## 12. 그리디
