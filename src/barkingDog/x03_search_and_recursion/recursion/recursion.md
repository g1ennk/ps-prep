# 재귀

<!-- TOC -->
* [재귀](#재귀)
  * [1. 개념](#1-개념)
  * [2. 연습 문제](#2-연습-문제)
    * [BOJ_1629_곱셈](#boj_1629_곱셈)
    * [BOJ_11729_하노이 탑 이동 순서](#boj_11729_하노이-탑-이동-순서)
    * [BOJ_1074_Z](#boj_1074_z)
<!-- TOC -->

## 1. 개념

1. 재귀란: 하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘
2. 수학적 귀납법
    - 설명 1: 1번 도미노가 쓰러진다 -> 이어 2번 도미노가 쓰러진다, 이어 3번 도미노가 쓰러진다. -> 모든 도미노가 쓰러진다
    - 설명 2(수학적 귀납법): 1번 도미노가 쓰러진다 -> k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다. -> 모든 도미노가 쓰러진다
    - 즉, 절차지향적인 사고를 벗어나야 한다.
3. 절차지향적 사고와 귀납적 사고
    - 절차지향적 사고: 3 출력 -> func(2) 호출 -> 2 출력 -> func(1) 호출 -> 1 출력 -> func(0) 호출 -> 종료
    - 귀납적 사고: func1(1)이 1을 출력한다 -> func(k)가 k k-1 k-2 1을 출력한다면, func(k+1)은 k+1 k k-1 1을 출력한다.
4. 재귀 함수의 조건
    - 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함(Base Condition)
    - 모든 입력은 base condition으로 수렴해야 함
5. 재귀에 대한 정보
    - 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함
    - 모든 재귀 함수는 반복문으로 동일한 동작을 하는 함수를 만들 수 있음
    - 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서는 손해를 봄
    - 한 함수가 자기 자신을 여러 번 호출하면 비효율적일 수 있음 (이미 계산한 걸 또 계산함, 추후 DP로 해결할 수 있음)
    - 재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨 (런타임 에러 발생 가능)

## 2. 연습 문제

### BOJ_1629_곱셈

1. A,B,C는 모두 큰 수가 들어올 수 있으므로 `int`가 아닌 `long`으로 받는다.
2. 종료되는 경우의 수는 두 가지 (Base Condition)
    - B가 0이 되거나 -> 값 자체는 1이지만 항상 mod를 해야함 -> `1 % C`
    - B가 1이 되거나 -> `A mod C` -> `A % C`
3. 분할 정복 (a^n * a^n = a^2n)
    - B의 값이 매우 클 수 있기 때문에 단순 재귀는 초과가 나타날 수 있음.
    - half를 구한 후 half를 두 번 곱해 나누는 방식이 효과적
    - B가 홀수인 경우와 짝수인 경우를 나눠서 생각해야 함.
        - B가 홀수인 경우: A를 한 번 더 곱해줘야 함
        - B가 짝수인 경우: result 그대로 반환
4. 중요한 건, 문제에서 다루는 값이 결과값이 아닌 mod 값이기 때문에 항상 mod를 달고 있어야 한다.

### BOJ_11729_하노이 탑 이동 순서

1. 함수의 정의
    1. n-1개를 from(기둥 1)에서 temp(기둥 2)로 옮긴다(재귀)
    2. 가장 큰 원반(바닥 원반)을 from(기둥 1)에서 to(기둥 3)로 옮긴다(출력 + count)
    3. temp(기둥 2)에 있는 n-1개를 to(기둥 3)로 옮긴다(재귀)
2. 종료 조건: n==1이면 from -> to로 1회 이동(출력)하고 count++.
3. 핵심은, 원판이 n-1개일 때 옮길 수 있으면 원판이 n개일 때에도 옮길 수 있다.
    - 원판이 1개일 때 내가 원하는 곳으로 옮길 수 있다 = 원판이 k개일 대 옮길 수 있으면 k+1개일 때도 옮길 수 있다.

### BOJ_1074_Z

1. 함수의 정의
    - int solve(int n, int r, int c) -> 2^n x 2^n 배열에서 (r,c)를 방문하는 순서를 반환하는 함수
2. 종료 조건
    - n = 0일 때, return 0;
3. 재귀식: (r,c)가
    - 0사분면: return solve(half, r, c);
    - 1사분면: return block + solve(half, r, c - half);
    - 2사분면: return 2 * block + solve(half, r - half, c);
    - 3사분면: return 3 * block + solve(half, r - half, c - half);

